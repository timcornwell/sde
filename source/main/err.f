C
C	National Radio Astronomy Observatory, Socorro, NM 87801
C	Software Development Environment (SDE)
C++
C @(#)err.f	1.2    11/7/90
C
C ensure that the error system functions even in the presence of
CD severe errors. Each callable routine makes use of the ERI_START
C routine to ensure that the error system can function, and the ERI_END
C routine to check it is OK to pass control back to application code.
C
C There is one routine which performs most error system operations,
C ERI_ACTION. One routine is used to avoid problems of recursion.
C It makes use of an internal context variable which keeps track of
C the most serious error condition encountered. It is this which is
C checked by ERI_END before returning to application code. The following
C values are used:
C
C	0 = normal operation, messages are written to the database
C		buffer.
C	1 = this value is used to force an error flush operation.
C	2 = an unreported database error has been found by ERI_START.
C		This is caused by faulty application code and causes
C		a fatal abort. The status is stored in ERI_UNREPORTED.
C	3 = an abort has been requested by application code.
C		This can occur from ERR_ABORT or ERR_DAT if a serious
C		database error is reported.
C	4 = the error system itself caused a database error. This also
C		causes a program abort. Only the first such error will
C		be reported. The status is stored in ERI_INTERNAL.
C
C Only if this context variable is zero are messages buffered to the
C database system. All other values cause messages to go directly to
C the message system.
C
C All the error routines check the status of the database error flag
C and reset it as needed. It should never be necessary for higher level
C routines to reset the database error status. It will be initially set
C OK by the ERI_INITIALIZE routine, and reset to OK by calls to
C ERR_DAT. Any database errors that go unreported to ERR_DAT will
C will be trapped by any of the other error routines. One of these
C will always be called, as ERR_FLUSH will be provided automatically
C as part of program run-down.
C
C Note that all calls to DAI_PUT use the internal buffer ERI_IN to
C hold the string. This ensures that all messages are stored in the
C database using the same length string. This, together with
C pre-allocated database nodes, helps make the error system more robust.
C A separate buffer (ERI_OUT) is used by the flush routine to avoid
C conflicts.
C
C The first character of each stored message is used as a code to
C indicate which message routine to use when flushed. This enables
C sophisticated filtering to be implemented if required.
C
      SUBROUTINE ERIACTIO
C
C Error system action routine
C All this code is in a single routine to avoid recursion
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C----------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
C
      CHARACTER*20 	NAME
      INTEGER 		I, N, NCHAR, NACTUAL, STRLEN, ERR
C======================================================================
C
C Come back here if an error detected in this routine
C
    1 CONTINUE
C
C Check for any database errors, they must have been generated by the
C error system itself so change the context to force an abort
C Only the first internal error can be reported
C This report is deferred until ERIEND
C
      IF(DATERROR.NE.DATOK) THEN
         IF(ERIINTRN.EQ.DATOK) ERIINTRN = DATERROR
         DATERROR = DATOK
         ERICNTXT = MAX(ERICNTXT,4)
      ENDIF
C
C If context severe enough flush all pending messages
C Carry on doing this even if errors occur, but note the first error
C Any problems here will be monitored in ERIEND
C
      IF(ERICNTXT.NE.0) THEN
         DO 2 I = 1,ERICOUNT
            NAME = ERINODE(I)
            N = STRLEN(NAME)
            NCHAR = LEN(ERIOUT)
            CALL DAIGET(NAME(1:N), N, 'C', 1, ERIOUT, 1, NCHAR, 
     1         NACTUAL, ERR)
            IF(DATERROR.EQ.DATOK) THEN
               CALL ERIWRITE
            ELSE
               IF(ERIINTRN.EQ.DATOK) ERIINTRN = DATERROR
               DATERROR = DATOK
               ERICNTXT = MAX(ERICNTXT,4)
            ENDIF
    2    CONTINUE
C
C Flag all messages sent
C
         ERICOUNT = 0
      ENDIF
C
C Write new error message to database if no problems
C
      IF(ERIIN.NE.' ') THEN
         IF(ERICNTXT.EQ.0) THEN
            NAME = ERINODE(ERICOUNT+1)
            N = STRLEN(NAME)
            NCHAR = LEN(ERIIN)
            CALL DAIPUT(NAME(1:N), N, 'C', 1, ERIIN, 1, NCHAR, ERR)
            IF(DATERROR.NE.DATOK) GOTO 1
            ERICOUNT = ERICOUNT + 1
C
C If there are problems write directly to message system
C
         ELSE
            ERIOUT = ERIIN
            CALL ERIWRITE
         ENDIF
      ENDIF
      END
      SUBROUTINE ERIEND
C
C Routine called by all error routines immediately before returning
C to user level code
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C--------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
C
      CHARACTER*40	DATERMS
C====================================================================
C
C Monitor unreported database errors
C
      IF(ERIUNRPT.NE.DATOK) THEN
         ERIIN = 'AUnreported database error detected by error system '
     +            //DATERMS(ERIUNRPT)
         CALL ERIACTIO
         ERIUNRPT = DATOK
      ENDIF
C
C Monitor internal error system errors
C
      IF(ERIINTRN.NE.DATOK) THEN
         ERIIN = 'ADatabase error within error system, '
     +            //DATERMS(ERIINTRN)
         CALL ERIACTIO
         ERIINTRN = DATOK
      ENDIF
C
C Abort at this point if signalled
C
      IF(ERICNTXT.GT.1) THEN
         CALL ERISTOP
         STOP
      ENDIF
C
C Return to user code if possible
C
      ERICNTXT = 0
      END
      SUBROUTINE ERIINITI
C
C Error system initialization
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C--------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
C
      CHARACTER*20 	NAME
      INTEGER 		I, N, NCHAR, STRLEN, ERR
C====================================================================
C
C Initialize common variables
C
      CALL ERRCANCE
      CALL ERISTART
C
C Set up a database entry
C
      NAME = 'ERISYSTEM'
      N = STRLEN (NAME)
      CALL DAICREAT(NAME(1:N), N, ERR)
C
C Pre-allocate some database nodes so that the error system can
C better operate in the presence of underlying database problems
C
      ERIIN = ' '
      DO 1 I = 1,20
         NAME = ERINODE(I)
         N = STRLEN(NAME)
         NCHAR = LEN(ERIIN)
         CALL DAIPUT(NAME(1:N), N, 'C', 1, ERIIN, 1, NCHAR, ERR)
    1 CONTINUE
C
C Return if all ok
C
      CALL ERIEND
      END
      CHARACTER*(*) FUNCTION ERINODE(N)
C
C Internal routine to generate database node name
C
C
C	N	INT	input	Error number
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C----------------------------------------------------------------------
C
      INTEGER 		N
      CHARACTER*20	STRTMP
C======================================================================
C
C Use number as node name
C
      WRITE(STRTMP,100) N
 100  FORMAT ('ERISYSTEM/ERROR', I4)
      ERINODE = STRTMP
      END
      SUBROUTINE ERISTART
C
C Routine called by all error routines on first entry from user code
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C--------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
C====================================================================
C
C Note any unreported database errors
C These must have come from faulty user level code
C
      IF(DATERROR.NE.DATOK) THEN
         ERIUNRPT = DATERROR
         DATERROR = DATOK
         ERICNTXT = MAX(ERICNTXT,2)
      ENDIF
      END
      SUBROUTINE ERISTOP
C
C Abort immediately
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C-----------------------------------------------------------------------
#include	"errinc.h"
C
C=======================================================================
C
      STOP
      END
      SUBROUTINE ERIWRITE
C
C Routine to send an error message in ERIOUT to the message system
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C---------------------------------------------------------------------
#include	"errinc.h"
C
C=====================================================================
C
C First character of message is a dispatch code
C
      CALL MSGPUT (ERIOUT(2:), ERIOUT(1:1))
C
      END
C++
C
      SUBROUTINE ERRCANCE
C
C Cancel all pending errors
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C--------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
C
C====================================================================
      ERROR = .FALSE.
      DATERROR = DATOK
      ERIUNRPT = DATOK
      ERIINTRN = DATOK
      ERISTAT = ' '
      ERICNTXT = 0
      ERICOUNT = 0
      END
C++
C
      SUBROUTINE ERRCHANG (REASON, ROUTINE, TEXT)
C
C Routine to change error status
C
C
C	REASON	CH*(*)	input	Reason for error report
C	ROUTINE	CH*(*)	input	Routine name in which error occurred
C	TEXT	CH*(*)	input	Further error text
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C-------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
      CHARACTER*(*) 	REASON	
      CHARACTER*(*) 	ROUTINE	
      CHARACTER*(*) 	TEXT	
C
C===================================================================
C
C Send message, the ROUTINE and TEXT strings are optional
C
      CALL ERISTART
      ERIIN = 'E'//REASON
      IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' in routine ',
     +                                     ROUTINE)
      IF(TEXT.NE.' ') CALL STRAPPE2 (ERIIN, ', ', TEXT)
      CALL ERIACTIO
C
C Check for no error status to change
C
      IF(.NOT.ERROR) THEN
         ERIIN = 
     +      'WAttempt to change error status when no error reported'
         IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' in routine ',
     +                                        ROUTINE)
         CALL ERIACTIO
      ENDIF
C
C Set error status and return
C
      ERROR = .TRUE.
      ERISTAT = REASON
      CALL ERIEND
      END
C++
C
      SUBROUTINE ERRDAT (REASON, ROUTINE, TEXT)
C
C Database error reporting routine
C
C
C	REASON	CH*(*)	input	Reason for error report
C	ROUTINE	CH*(*)	input	Routine name in which error occurred
C	TEXT	CH*(*)	input	Further error text
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C-------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
      CHARACTER*(*) 	REASON	
      CHARACTER*(*) 	ROUTINE	
      CHARACTER*(*) 	TEXT	
C
C
      INTEGER 		SAVEERR
      CHARACTER*40	DATERCD, DATERMS
C===================================================================
C
C Save and reset database error status
C
      SAVEERR = DATERROR
      DATERROR = DATOK
      CALL ERISTART
C
C Serious database errors always use the standard messages and cause
C an abort
C
      IF(SAVEERR.EQ.DATFATAL .OR. SAVEERR.EQ.DATCRRPT)
     +                                  THEN
         ERIIN = 'A'//DATERCD(SAVEERR)
         IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' in routine ',
     +                                        ROUTINE)
         CALL STRAPPE2 (ERIIN, ', ', DATERMS(SAVEERR))
         ERICNTXT = MAX(ERICNTXT,3)
C
C Less serious errors use either the supplied or default messages
C
      ELSEIF(SAVEERR.NE.DATOK) THEN
         IF(REASON.NE.' ') THEN
            ERIIN = 'E'//REASON
         ELSE
            ERIIN = 'E'//DATERCD(SAVEERR)
         ENDIF
         IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' in routine ',
     +                                        ROUTINE)
         IF(TEXT.NE.' ') THEN
            CALL STRAPPE2 (ERIIN, ', ', TEXT)
         ELSE
            CALL STRAPPE2 (ERIIN, ', ',
     +                        DATERMS(SAVEERR))
         ENDIF
C
C Database error not found
C
      ELSE
         ERIIN = 'WDatabase error reported but not found'
         IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' in routine ',
     +                                        ROUTINE)
      ENDIF
      CALL ERIACTIO
C
C Check for multiple errors
C
      IF(ERROR) THEN
         ERIIN = 'WMultple errors reported'
         IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' by routine ',
     +                                        ROUTINE)
         CALL ERIACTIO
      ENDIF
C
C Set error status and return or abort
C
      ERROR = .TRUE.
      IF(REASON.NE.' ') THEN
         ERISTAT = REASON
      ELSE
         ERISTAT = DATERCD(SAVEERR)
      ENDIF
      CALL ERIEND
      END
C++
C
      SUBROUTINE ERRFLUSH
C
C Flush all pending error messages
C
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C--------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
C
C====================================================================
C
C Change error system context to force a flush
C
      CALL ERISTART
      ERICNTXT = MAX(ERICNTXT,1)
      ERIIN = ' '
      CALL ERIACTIO
      CALL ERIEND
      END
C++
C
      SUBROUTINE ERRREASO (REASON)
C
C Return error reason string
C
C	REASON	CH*(*)	output	Reason for last error
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C-------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
      CHARACTER*(*)	REASON
C
      INTEGER		N, STRLEN
C===================================================================
      N = STRLEN (ERISTAT)
      REASON(1:N) = ERISTAT(1:N)
      END
C++
C
      SUBROUTINE ERRREPOR (REASON, ROUTINE, TEXT)
C
C Error reporting routine
C
C
C	REASON	CH*(*)	input	Reason for error report
C	ROUTINE	CH*(*)	input	Routine name in which error occurred
C	TEXT	CH*(*)	input	Further error text
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C-------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
      CHARACTER*(*) 	REASON	
      CHARACTER*(*) 	ROUTINE	
      CHARACTER*(*) 	TEXT	
C
C===================================================================
C
C Send message, the ROUTINE and TEXT strings are optional
C
      CALL ERISTART
      ERIIN = 'E'//REASON
      IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' in routine ',
     +                                     ROUTINE)
      IF(TEXT.NE.' ') CALL STRAPPE2 (ERIIN, ', ', TEXT)
      CALL ERIACTIO
C
C Check for multiple errors
C
      IF(ERROR) THEN
         ERIIN = 'WMultiple errors reported'
         IF(ROUTINE.NE.' ') CALL STRAPPE2 (ERIIN, ' by routine ',
     +                                        ROUTINE)
         CALL ERIACTIO
      ENDIF
C
C Set error status and return
C
      ERROR = .TRUE.
      ERISTAT = REASON
      CALL ERIEND
      END
C++
C
      SUBROUTINE ERRTRACE (ROUTINE)
C
C Error traceback routine
C
C 	ROUTINE	CH*(*)	input	Name of routine
C Audit trail:
C	Original version: Audit trail comments go on this line
C	and successive lines
C				T.J.Cornwell	Jan 5 1989
C
C-------------------------------------------------------------------
#include	"stdinc.h"
#include	"datinc.h"
#include	"errinc.h"
C
      CHARACTER*(*)	ROUTINE	
C
C===================================================================
C
C Check for error condition
C
      CALL ERISTART
      IF(ERROR) THEN
C
C Send message
C
         ERIIN = 'TCalled from routine '//ROUTINE
         CALL ERIACTIO
      ENDIF
C
C Return
C
      CALL ERIEND
      END
