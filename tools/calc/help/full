		CALC - An arbitrary precision calculator.
			by David I. Bell


Quick introduction

	This is an interactive calculator which provides for easy large
	numeric calculations, but which also can be easily programmed
	for difficult or long calculations.  It can accept a command line
	argument, in which case it executes that single command and exits.
	Otherwise, it enters interactive mode.  In this mode, it accepts
	commands one at a time, processes them, and displays the answers.
	In the simplest case, commands are simply expressions which are
	evaluated.  For example, the following line can be input:

		3 * (4 + 1)

	and the calculator will print 15.

	The special '.' symbol (called dot), represents the result of the
	last command expression, if any.  This is of great use when a series
	of partial results are calculated, or when the output mode is changed
	and the last result needs to be redisplayed.  For example, the above
	result can be doubled by typing:

		. * 2

	and the calculator will print 30.

	For more complex calculations, variables can be used to save the
	intermediate results.  For example, the result of adding 7 to the
	previous result can be saved by typing:

		old = . + 7

	Functions can be used in expressions.  There are a great number of
	pre-defined functions.  For example, the following will calculate
	the factorial of the value of 'old':

		fact(old)

	and the calculator prints 13763753091226345046315979581580902400000000.
	Notice that numbers can be very large. (There is a practical limit
	of several thousand digits before calculations become too slow.)

	The calculator can calculate transcendental functions, and accept and
	display numbers in real or exponential format. For example, typing:

		config("display", 50)
		epsilon(1e-50)
		sin(1)

	prints "~.84147098480789650665250232163029899962256306079837".

	The calculator also knows about complex numbers, so that typing:

		(2+3i) * (4-3i)

	prints "17+6i".


Command sequence

	This is a sequence of any the following command formats, where
	each command is terminated by a semicolon or newline.  Long command
	lines can be extended by using a back-slash followed by a newline
	character.  When this is done, the prompt shows a double angle
	bracket to indicate that the line is still in progress.  Certain
	cases will automatically prompt for more input in a similar manner,
	even without the back-slash.  The most common case for this is when
	a function is being defined, but is not yet completed.

	Each command sequence terminates only on an end of file.  In
	addition, commands can consist of expression sequences, which are
	described in the next section.


	NOTE: Calc commands are in lower case.   UPPER case is used below
	      for emphasis only, and should be considered in lower case.


	DEFINE function(params) { body }
	DEFINE function(params) = expression
		This first form defines a full function which can consist
		of declarations followed by many statements which implement
		the function.

		The second form defines a simple function which calculates
		the specified expression value from the specified parameters.
		The expression cannot be a statement.  However, the comma
		and question mark operators can be useful.  Examples of
		simple functions are:

			define sumcubes(a, b) = a^3 + b^3;
			define pimod(a) = a % pi();

	HELP
		This displays a general help message.

	READ filename
		This reads definitions from the specified filename.
		The name can be quoted if desired.  The calculator
		uses the CALCPATH environment variable to search
		through the specified directories for the filename,
		similarly to the use of the PATH environment variable.
		If CALCPATH is not defined, then a default path of
		":/usr/lib/calc" is used (that is, the current directory
		followed by a general calc library directory).  The
		".cal" extension is defaulted for input files, so that
		if "filename" is not found, then "filename.cal" is then
		searched for.  The contents of the filename are command
		sequences which can consist of expressions to evaluate
		or functions to define, just like at the top level
		command level.

	WRITE filename
		This writes the values of all global variables to the
		specified filename, in such a way that the file can be
		later read in order to recreate the variable values.
		For speed reasons, values are written as hex fractions.
		This command currently only saves simple types, so that
		matrices, lists, and objects are not saved.  Function
		definitions are also not saved.

	QUIT
		This leaves the calculator, when given as a top-level
		command.
	

	Also see the help topic:

		statement       flow control and declaration statements


Expression sequences

	This is a sequence of statements, of which expression statements
	are the commonest case.  Statements are separated with semicolons,
	and the newline character generally ends the sequence.  If any
	statement is an expression by itself, or is associated with an
	'if' statement which is true, then two special things can happen.
	If the sequence is executed at the top level of the calculator,
	then the value of '.' is set to the value of the last expression.
	Also, if an expression is a non-assignment, then the value of the
	expression is automatically printed if its value is not NULL.
	Some operations such as	pre-increment and plus-equals are also
	treated as assignments.

	Examples of this are the following:

	expression		sets '.' to		prints
	----------		-----------		------
	3+4			7			7
	2*4; 8+1; fact(3)	6			8, 9, and 6
	x=3^2			9			-
	if (3 < 2) 5; else 6	6			6
	x++			old x			-
	print fact(4)		-			24
	null()			null()			-

	Variables can be defined at the beginning of an expression sequence.
	This is most useful for local variables, as in the following example,
	which sums the square roots of the first few numbers:

	local s, i; s = 0; for (i = 0; i < 10; i++) s += sqrt(i); s

	If a return statement is executed in an expression sequence, then
	the result of the expression sequence is the returned value.  In
	this case, '.' is set to the value, but nothing is printed.


Function definitions

	Function definitions are introduced by the 'define' keyword.
	Other than this, the basic structure of a function is like in C.
	That is, parameters are specified for the function within parenthesis,
	the function body is introduced by a left brace, variables are
	declared for the function, statements implementing the function
	follow, and the function is ended with a right brace.

	There are some subtle differences, however.  The types of parameters
	and variables are not defined at compile time, but instead are typed
	at runtime.  Thus there is no definitions needed to distinguish
	between integers, fractions, complex numbers, matrices, and so on.
	Thus when declaring parameters for a function, only the name of
	the parameter is needed.  Thus there are never any declarations
	between the function parameter list and the body of the function.

	For example, the following function computes a factorial:

		define factorial(n)
		{
			local	ans;

			ans = 1;
			while (n > 1)
				ans *= n--;
			return ans;
		}

	If a function is very simple and just returns a value, then the
	function can be defined in shortened manner by using an equals sign
	in place of the left brace.  In this case, the function declaration
	is terminated by a newline character, and its value is the specified
	expression.  Statements such as 'if' are not allowed.  An optional
	semicolon ending the expression is allowed.  As an example, the
	average of two numbers could be defined as:

		define average(a, b) = (a + b) / 2;

	Functions can be defined which can be very complex.  These can be
	defined on the command line if desired, but editing of partial
	functions is not possible past a single line.  If an error is made
	on a previous line, then the function must be finished (with probable
	errors) and reentered from the beginning.  Thus for complicated
	functions, it is best to use an editor to create the function in a
	file, and then enter the calculator and read in the file containing
	the definition.

	The parameters of a function can be referenced by name, as in
	normal C usage, or by using the 'param' function.  This function
	returns the specified parameter of the function it is in, where
	the parameters are numbered starting from 1.  The total number
	of parameters to the function is returned by using 'param(0)'.
	Using this function allows you to implement varargs-like routines
	which can handle any number of calling parameters.  For example:

		define sc()
		{
			local s, i;

			s = 0;
			for (i = 1; i <= param(0); i++)
				s += param(i)^3;
			return s;
		}

	defines a function which returns the sum of the cubes of all it's
	parameters.


Variable declarations

	Variables can be declared as either being global or local.
	Global variables are visible to all functions and on the command
	line.  Local variables are visible only within a single function or
	command sequence.  When the function or command sequence returns,
	the local variables are deleted.

	To declare one or more variables, the 'local' or 'global' keywords
	are used, followed by the desired list of variable names, separated
	by commas.  The definition is terminated with a semicolon.  Examples
	of declarations are:

		local	x, y, z;
		global	fred;
		local	foo, bar;

	Within function declarations, all variables must be defined.
	But on the top level command line, assignments automatically define
	global variables as needed.  For example, on the top level command
	line, the following defines the global variable x if it had not
	already been defined:

		x = 7

	Variables have no fixed type, thus there is no need or way to
	specify the types of variables as they are defined.  Instead, the
	types of variables change as they are assigned to or are specified
	in special statements such as 'mat' and 'obj'.  When a variable is
	first defined using 'local' or 'global', it has the null type.

	If a procedure defines a local variable name which matches a
	global variable name, or has a parameter name which matches a
	global variable name, then the local variable or parameter takes
	precedence within that procedure, and the global variable is not
	directly accessible.

	There are no pointers in the calculator language, thus all
	arguments to user-defined functions are normally passed by value.
	This is true even for matrices, strings, and lists.  In order
	to circumvent this, the '&' operator is allowed before a variable
	when it is an argument to a function.  When this is done, the
	address of the variable is passed to the function instead of its
	value.  This is true no matter what the type of the variable is.
	This allows for fast calls of functions when the passed variable
	is huge (such as a large array).  However, the passed variable can
	then be changed by the function if the parameter is assigned into.
	The function being called does not need to know if the variable
	is being passed by value or by address.

	Built-in functions and object functions always accept their
	arguments as addresses, thus there is no need to use '&' when
	calling built-in functions.


Statements

	Statements are very much like C statements.  Most statements act
	identically to those in C, but there are minor differences and
	some additions.  The following is a list of the statement types,
	with explanation of the non-C statements.  In this list, upper
	case words identify the keywords which are actually in lower case.
	Statements are generally terminated with semicolons, except if the
	statement is the compound one formed by matching braces.  Various
	expressions are optional and may be omitted (as in RETURN).


	NOTE: Calc commands are in lower case.   UPPER case is used below
	      for emphasis only, and should be considered in lower case.


	IF (expr) statement
	IF (expr) statement ELSE statement
	FOR (optionalexpr ; optionalexpr ; optionalexpr) statement
	WHILE (expr) statement
	DO statement WHILE (expr)
	CONTINUE
	BREAK
	GOTO label
		These all work like in normal C.

	RETURN optionalexpr
		This returns a value from a function.  Functions always
		have a return value, even if this statement is not used.
		If no return statement is executed, or if no expression
		is specified in the return statement, then the return
		value from the function is the null type.

	SWITCH (expr) { caseclauses }
		Switch statements work similarly to C, except for the
		following.  A switch can be done on any type of value,
		and the case statements can be of any type of values.
		The case statements can also be expressions calculated
		at runtime.  The calculator compares the switch value
		with each case statement in the order specified, and
		selects the first case which matches.  The default case
		is the exception, and only matches once all other cases
		have been tested.

	{ statements }
		This is a normal list of statements, each one ended by
		a semicolon.  Unlike the C language, no declarations are
		permitted within an inner-level compound statement.
		Declarations are only permitted at the beginning of a
		function definition, or at the beginning of an expression
		sequence.

	MAT variable [dimension] [dimension] ...
	MAT variable [dimension, dimension, ...]

		This creates a matrix variable with the specified dimensions.
		Matrices can have from 1 to 4 dimensions.  When specifying
		multiple dimensions, you can use either the standard C syntax,
		or else you can use commas for separating the dimensions.
		For example, the following two statements are equivalent,
		and so will create the same two dimensional matrix:

			mat foo[3][6];
			mat foo[3,6];

		By default, each dimension is indexed starting at zero,
		as in normal C, and contains the specified number of
		elements.  However, this can be changed if a colon is
		used to separate two values.  If this is done, then the
		two values become the lower and upper bounds for indexing.
		This is convenient, for example, to create matrices whose
		first row and column begin at 1.  Examples of matrix
		definitions are:

			mat x[3]	one dimension, bounds are 0-2
			mat foo[4][5]	two dimensions, bounds are 0-3 and 0-4
			mat a[-7:7]	one dimension, bounds are (-7)-7
			mat s[1:9,1:9]	two dimensions, bounds are 1-9 and 1-9

		Note that the MAT statement is not a declaration, but is
		executed at runtime.  Within a function, the specified
		variable must already be defined, and is just converted to
		a matrix of the specified size, and all elements are set
		to the value of zero.  For convenience, at the top level
		command level, the MAT command automatically defines a
		global variable of the specified name if necessary.

		Since the MAT statement is executed, the bounds on the
		matrix can be full expressions, and so matrices can be
		dynamically allocated.  For example:

			size = 20;
			mat data[size*2];

		allocates a matrix which can be indexed from 0 to 39.

	OBJ type { elementnames } optionalvariables
	OBJ type variables

		These create a new object type, or create one or more
		variables of the specified type.  For this calculator,
		an object is just a structure which is implicitly acted
		on by user defined routines.  The user defined routines
		implement common operations for the object, such as plus
		and minus, multiply and divide, comparison and printing.
		The calculator will automatically call these routines in
		order to perform many operations.
	
		To create an object type, the data elements used in
		implementing the object are specified within a pair
		of braces, separated with commas.  For example, to
		define an object will will represent points in 3-space,
		whose elements are the three coordinate values, the
		following could be used:
	
			obj point {x, y, z};
	
		This defines an object type called point, whose elements
		have the names x, y, and z.  The elements are accessed
		similarly to structure element accesses, by using a period.
		For example, given a variable 'v' which is a point object,
		the three coordinates of the point can be referenced by:

			v.x
			v.y
			v.z

		A particular object type can only be defined once, and
		is global throughout all functions.  However, different
		object types can be used at the same time.

		In order to create variables of an object type, they
		can either be named after the right brace of the object
		creation statement, or else can be defined later with
		another obj statement.  To create two points using the
		second (and most common) method, the following is used:

			obj point p1, p2;	

		This statement is executed, and is not a declaration.
		Thus within a function, the variables p1 and p2 must have
		been previously defined, and are just changed to be the
		new object type.  For convenience, at the top level command
		level, object variables are automatically defined as being
		global when necessary.

	EXIT string
	QUIT string

		This command is used in two cases.  At the top command
		line level, quit will exit from the calculator.  This
		is the normal way to leave the calculator.  In any other
		use, quit will abort the current calculation as if an
		error had occurred.  If a string is given, then the string
		is printed as the reason for quitting, otherwise a general
		quit message is printed.  The routine name and line number
		which executed the quit is also printed in either case.

		Quit is useful when a routine detects invalid arguments,
		in order to stop a calculation cleanly.  For example,
		for a square root routine, an error can be given if the
		supplied parameter was a negative number, as in:

			define mysqrt(n)
			{
				if (n < 0)
					quit "Negative argument";
				...
			}

		Exit is an alias for quit.


	PRINT exprs

		For interactive expression evaluation, the values of all
		typed-in expressions are automatically displayed to the
		user.  However, within a function or loop, the printing of
		results must be done explicitly.  This can be done using
		the 'printf' or 'fprintf' functions, as in standard C, or
		else by using the built-in 'print' statement.  The advantage
		of the print statement is that a format string is not needed.
		Instead, the given values are simply printed with zero or one
		spaces between each value.

		Print accepts a list of expressions, separated either by
		commas or colons.  Each expression is evaluated in order
		and printed, with no other output, except for the following
		special cases.  The comma which separates expressions prints
		a single space, and a newline is printed after the last
		expression unless the statement ends with a colon.  As
		examples:

			print 3, 4;		prints "3 4" and newline.
			print 5:;		prints "5" with no newline.
			print 'a' : 'b' , 'c';	prints "ab c" and newline.
			print;			prints a newline.

		For numeric values, the format of the number depends on the
		current "mode" configuration parameter.  The initial mode
		is to print real numbers, but it can be changed to other
		modes such as exponential, decimal fractions, or hex.

		If a matrix or list is printed, then the elements contained
		within the matrix or list will also be printed, up to the
		maximum number specified by the "maxprint" configuration
		parameter.  If an element is also a matrix or a list, then
		their values are not recursively printed.  Objects are printed
		using their user-defined routine.  Printing a file value
		prints the name of the file that was opened.


	SHOW item

		This command displays some information.
		The following is a list of the various items:

			builtins	built in functions
			globals		global variables
			functions	user-defined functions
			objfuncs	possible object functions
			memory		memory usage
	

	Also see the help topic:

		command         top level commands


Operators

	The operators are similar to C, but the precedence of most of
	the operators differs.  In addition, there are several additional
	operators, and some C operators are missing.  The following list
	gives the operators arranged in order of precedence, from the
	least tightly binding to the most tightly binding.


	,	Comma operator.
		For situations in which a comma is used for another purpose
		(function arguments, array indexing, and the print statement),
		parenthesis must be used around the comma operator.

	a?:b:c	Conditional value.
		The test for 'a' is identical to an if test.

	=  +=  -=  *=  /=  %=  //=  &=  |=  <<=  >>=  ^=  **=
		Assignments.

	||	Conditional OR.
		Unlike C, the result is the first non-zero expression or 0,
		instead of just 0 or 1.

	&&	Conditional AND.
		Unlike C, the result is the last expression or 0,
		instead of just 0 or 1.

	==  !=  <=  >=  <  >
		Relations.

	+  -
		Binary plus and minus.

	*  /  //  %
		Multiply, divide. and modulo.
		Please Note: The '/' operator is a fractional divide,
		whereas the '//' is an integral divide.  Thus think of '/'
		as division of real numbers, and think of '//' as division
		of integers (e.g., 8 / 3 is 8/3 whereas 8 // 3 is 2).
		The '%' is integral or fractional modulus (e.g., 11%4 is 3,
		and 10%pi() is ~.575222).

	|	Logical OR.
		The signs of numbers do not affect the bit value.

	&	Logical AND.
		The signs of numbers do not affect the bit value.

	^  **  <<  >>
		Powers and shifts.
		The '^' and '**' are both exponentiation (e.g., 2^3 is 8).
		The signs of numbers do not affect the bit values of shifts.
		These operators associate rightward (e.g., 1<<3^2 is 512).

	+  -  !
		Unary operators.
		The '!' is the logical NOT operator.  Be careful about
		using this as the first character of a top level command,
		since it is also used for executing UNIX commands.

	++  --
		Pre or post indexing.
		These are applicable only to variables.

	[ ]  [[ ]]  .  ( )
		Indexing, double-bracket indexing, element references,
		and function calls.  Indexing can only be applied to matrices,
		element references can only be applied to objects, but
		double-bracket indexing can be applied to matrices, objects,
		or lists.

	variables  constants  .  ( )
		These are variable names and constants, the special '.' symbol,
		or a parenthesized expression.  Variable names begin with a
		letter, but then can contain letters, digits, or underscores.
		Constants are numbers in various formats, or strings inside
		either single or double quote marks.


Builtin types

	The calculator has the following built-in types.

	null value
		This is the undefined value type.  The function 'null'
		returns this value.  Functions which do not explicitly
		return a value return this type.  If a function is called
		with fewer parameters than it is defined for, then the
		missing parameters have the null type.  Defining a
		new variable initializes it to the null type.  The null
		value is false if used in an IF test.

	rational numbers
		This is the basic data type of the calculator.
		These are fractions whose numerators and denominators
		can be arbitrarily large.  The fractions are always
		in lowest terms.  Integers have a denominator of 1.
		The numerator of the number contains the sign, so that
		the denominator is always positive.  When a number is
		entered in floating point or exponential notation, it is
		immediately converted to the appropriate fractional value.
		Printing a value as a floating point or exponential value
		involves a conversion from the fractional representation.

		Numbers are stored in binary format, so that in general,
		bit tests and shifts are quicker than multiplies and divides.
		Similarly, entering or displaying of numbers in binary,
		octal, or hex formats is quicker than in decimal.  The
		sign of a number does not affect the bit representation
		of a number.

	complex numbers
		Complex numbers are composed of real and imaginary parts,
		which are both fractions as defined above.  An integer which
		is followed by an 'i' character is a pure imaginary number.
		Complex numbers such as "2+3i" when typed in, are processed
		as the sum of a real and pure imaginary number, resulting
		in the desired complex number.  Therefore, parenthesis are
		sometimes necessary to avoid confusion, as in the two values:

			1+2i ^2		(which is -3)
			(1+2i) ^2	(which is -3+4i)

		Similar care is required when entering fractional complex
		numbers.  Note the differences below:

			3/4i		(which is -(3/4)i)
			3i/4		(which is (3/4)i)

		The imaginary unit itself is input using "1i".

	strings
		Strings are a sequence of zero or more characters.
		They are input using either of the single or double
		quote characters.  The quote mark which starts the
		string also ends it.  Various special characters can
		also be inserted using back-slash.  Example strings:

			"hello\n"
			"that's all"
			'lots of """"'
			'a'
			""

		There is no distinction between single character and
		multi-character strings.  The 'str' and 'ord' functions
		will convert between a single character string and its
		numeric value.  The 'str' and 'eval' functions will
		convert between longer strings and the corresponding
		numeric value (if legal).  The 'strcat', 'strlen', and
		'substr' functions are also useful.

	matrices
		These are one to four dimensional matrices, whose minimum
		and maximum bounds can be specified at runtime.  Unlike C,
		the minimum bounds of a matrix do not have to start at 0.
		The elements of a matrix can be of any type.  There are
		several built-in functions for matrices.  Matrices are
		created using the 'mat' statement.


	lists
		These are a sequence of values, which are linked together
		so that elements can be easily be inserted or removed
		anywhere in the list.  The values can be of any type.
		Lists are created using the 'list' function.

	files
		These are text files opened using stdio.  Files may be opened
		for sequential reading, writing, or appending.  Opening a
		file using the 'fopen' function returns a value which can
		then be used to perform I/O to that file.  File values can
		be copied by normal assignments between variables, or by
		using the result of the 'files' function.  Such copies are
		indistinguishable from each other.


Using objects

	Objects are user-defined types which are associated with user-
	defined functions to manipulate them.  Object types are defined
	similarly to structures in C, and consist of one or more elements.
	The advantage of an object is that the user-defined routines are
	automatically called by the calculator for various operations,
	such as addition, multiplication, and printing.  Thus they can be
	manipulated by the user as if they were just another kind of number.

	An example object type is "surd", which represents numbers of the form

		a + b*sqrt(D),

	where D is a fixed integer, and 'a' and 'b' are arbitrary rational
	numbers.  Addition, subtraction, multiplication, and division can be
	performed on such numbers, and the result can be put unambiguously
	into the same form.  (Complex numbers are an example of surds, where
	D is -1.)

	The "obj" statement defines either an object type or an actual
	variable of that type.  When defining the object type, the names of
	its elements are specified inside of a pair of braces.  To define
	the surd object type, the following could be used:

		obj surd {a, b};

	Here a and b are the element names for the two components of the
	surd object.

	When an object is created, the elements are all defined with null
	values.  A user-defined routine should be provided which will place
	useful values in the elements.  For example, for an object of type
	'surd', a function called 'surd' can be defined to set the two
	components as follows:
	
		define surd(a, b)
		{
			local x;

			obj surd x;
			x.a = a;
			x.b = b;
			return x;
		}

	When an operation is attempted for an object, user functions with
	particular names are automatically called to perform the operation.
	These names are created by concatenating the object type name and
	the operation name together with an underscore.  For example, when
	multiplying two objects of type surd, the function "surd_mul" is
	called.

	The user function is called with the necessary arguments for that
	operation.  For example, for "surd_mul", there are two arguments,
	which are the two numbers.  The order of the arguments is always
	the order of the binary operands.  If only one of the operands to
	a binary operator is an object, then the user function for that
	object type is still called.  If the two operands are of different
	object types, then the user function that is called is the one for
	the first operand.

	The above rules mean that for full generality, user functions
	should detect that one of their arguments is not of its own object
	type by using the 'istype' function, and then handle these cases
	specially.  In this way, users can mix normal numbers with object
	types.  (Functions which only have one operand don't have to worry
	about this.)  The following example of "surd_mul" demonstrates how
	to handle regular numbers when used together with surds:

		define surd_mul(a, b)
		{
			local x;

			obj surd x;
			if (!istype(a, x)) {	
				/* a not of type surd */
				x.a = b.a * a;
				x.b = b.b * a;
			} else if (!istype(b, x)) {
				/* b not of type surd */
				x.a = a.a * b;
				x.b = a.b * b;
			} else {			
				/* both are surds */
				x.a = a.a * b.a + D * a.b * b.b;
				x.b = a.a * b.b + a.b * b.a;
			}
			if (x.b == 0)
				return x.a;	/* normal number */
			return x;		/* return surd */
		}

	In order to print the value of an object nicely, a user defined
	routine can be provided.  For small amounts of output, the print
	routine should not print a newline.  Also, it is most convenient
	if the printed object looks like the call to the creation routine.
	For output to be correctly collected within nested output calls,
	output should only go to stdout.  This means use the 'print'
	statement, the 'printf' function, or the 'fprintf' function with
	'files(1)' as the output file.  For example, for the "surd" object:

		define surd_print(a)
		{
			print "surd(" : a.a : "," : a.b : ")" : ;
		}

	It is not necessary to provide routines for all possible operations
	for an object, if those operations can be defaulted or do not make
	sense for the object.  The calculator will attempt meaningful
	defaults for many operations if they are not defined.  For example,
	if 'surd_square' is not defined to square a number, then 'surd_mul'
	will be called to perform the squaring.  When a default is not
	possible, then an error will be generated.

	Please note: Arguments to object functions are always passed by
	reference (as if an '&' was specified for each variable in the call).
	Therefore, the function should not modify the parameters, but should
	copy them into local variables before modifying them.  This is done
	in order to make object calls quicker in general.

	The double-bracket operator can be used to reference the elements
	of any object in a generic manner.  When this is done, index 0
	corresponds to the first element name, index 1 to the second name,
	and so on.  The 'size' function will return the number of elements
	in an object.

	The following is a list of the operations possible for objects.
	The 'xx' in each function name is replaced with the actual object
	type name.  This table is displayed by the 'show objfuncs' command.

		Name	Args	Comments

		xx_print    1	print value, default prints elements
		xx_one      1	multiplicative identity, default is 1
		xx_test     1	logical test (false,true => 0,1), 
				    default tests elements
		xx_add      2	
		xx_sub      2	subtraction, default adds negative
		xx_neg      1	negative
		xx_mul      2	
		xx_div      2	non-integral division, default multiplies 
				    by inverse
		xx_inv      1	multiplicative inverse
		xx_abs      2	absolute value within given error
		xx_norm     1	square of absolute value
		xx_conj     1	conjugate
		xx_pow      2	integer power, default does multiply, 
				    square, inverse
		xx_sgn      1	sign of value (-1, 0, 1)
		xx_cmp      2	equality (equal,non-equal => 0,1), 
				    default tests elements
		xx_rel      2	inequality (less,equal,greater => -1,0,1)
		xx_quo      2	integer quotient
		xx_mod      2	remainder of division
		xx_int      1	integer part
		xx_frac     1	fractional part
		xx_inc      1	increment, default adds 1
		xx_dec      1	decrement, default subtracts 1
		xx_square   1	default multiplies by itself
		xx_scale    2	multiply by power of 2
		xx_shift    2	shift left by n bits (right if negative)
		xx_round    2	round to given number of decimal places
		xx_bround   2	round to given number of binary places
		xx_root     3	root of value within given error
		xx_sqrt     2	square root within given error


	Also see the library files:

		dms.cal
		mod.cal
		poly.cal
		quat.cal
		surd.cal


Using matrices

	Matrices can have from 1 to 4 dimensions, and are indexed by a
	normal-sized integer.  The lower and upper bounds of a matrix can
	be specified at runtime.  The elements of a matrix are defaulted
	to zeroes, but can be assigned to be of any type.  Thus matrices
	can hold complex numbers, strings, objects, etc.  Matrices are
	stored in memory as an array so that random access to the elements
	is easy.

	Matrices are normally indexed using square brackets.  If the matrix
	is multi-dimensional, then an element can be indexed either by
	using multiple pairs of square brackets (as in C), or else by
	separating the indexes by commas.  Thus the following two statements
	reference the same matrix element:

		x = name[3][5];
		x = name[3,5];

	The double-square bracket operator can be used on any matrix to
	make references to the elements easy and efficient.  This operator
	bypasses the normal indexing mechanism, and treats the array as if
	it was one-dimensional and with a lower bound of zero.  In this
	indexing mode, elements correspond to the normal indexing mode where
	the rightmost index increases most frequently.  For example, when
	using double-square bracket indexing on a two-dimensional matrix,
	increasing indexes will reference the matrix elements left to right,
	row by row.  Thus in the following example, 'x' and 'y' are copied
	from the same matrix element:

		mat m[1:2, 1:3];
		x = m[2,1];
		y = m[[3]];

	There are functions which return information about a matrix.
	The 'size' functions returns the total number of elements.
	The 'matdim', 'matmin', and 'matmax' functions return the number
	of dimensions of a matrix, and the lower and upper index bounds
	for a dimension of a matrix.  For square matrices, the 'det'
	function calculates the determinant of the matrix.

	Some functions return matrices as their results.  These	functions
	do not affect the original matrix argument, but instead return
	new matrices.  For example, the 'mattrans' function returns the
	transpose of a matrix, and 'inverse' returns the inverse of a
	matrix.  So to invert a matrix called 'x', you could use:

		x = inverse(x);

	The 'matfill' function fills all elements of a matrix with the
	specified value, and optionally fills the diagonal elements of a
	square matrix with a different value.  For example:

		matfill(x,1);

	will fill any matrix with ones, and:

		matfill(x, 0, 1);

	will create an identity matrix out of any square matrix.  Note that
	unlike most matrix functions, this function does not return a matrix
	value, but manipulates the matrix argument itself.

	Matrices can be multiplied by numbers, which multiplies each element
	by the number.  Matrices can also be negated, conjugated, shifted,
	rounded, truncated, fraction'ed, and modulo'ed.  Each of these
	operations is applied to each element.

	Matrices can be added or multiplied together if the operation is
	legal.  Note that even if the dimensions of matrices are compatible,
	operations can still fail because of mismatched lower bounds.  The
	lower bounds of two matrices must either match, or else one of them
	must have a lower bound of zero.  Thus the following code:

		mat x[3:3];
		mat y[4:4];
		z = x + y;

	fails because the calculator does not have a way of knowing what
	the bounds should be on the resulting matrix.  If the bounds match,
	then the resulting matrix has the same bounds.  If exactly one of
	the lower bounds is zero, then the resulting matrix will have the
	nonzero lower bounds.  Thus means that the bounds of a matrix are
	preserved when operated on by matrices with lower bounds of zero.
	For example:

		mat x[3:7];
		mat y[5];
		z = x + y;

	will succeed and assign the variable 'z' a matrix whose
	bounds are 3-7.

	Vectors are matrices of only a single dimension.  The 'dp' and 'cp'
	functions calculate the dot product and cross product of a vector
	(cross product is only defined for vectors of size 3).

	Matrices can be searched for particular values by using the 'search'
	and 'rsearch' functions.  They return the element number of the
	found value (zero based), or null if the value does not exist in the
	matrix.  Using the element number in double-bracket indexing will
	then refer to the found element.


Using lists

	Lists are a sequence of values which are doubly linked so that
	elements can be removed or inserted anywhere within the list.
	The function 'list' creates a list with possible initial elements.
	For example,

		x = list(4, 6, 7);

	creates a list in the variable x of three elements, in the order
	4, 6, and 7.

	The 'push' and 'pop' functions insert or remove an element from
	the beginning of the list.  The 'append' and 'remove' functions
	insert or remove an element from the end of the list.  The 'insert'
	and 'delete' functions insert or delete an element from the middle
	(or ends) of a list.  The functions which insert elements return
	the null value, but the functions which remove an element return
	the element as their value.  The 'size' function returns the number
	of elements in the list.

	Note that these functions manipulate the actual list argument,
	instead of returning a new list.  Thus in the example:

		push(x, 9);

	x becomes a list of four elements, in the order 9, 4, 6, and 7.
	Lists can be copied by assigning them to another variable.

	An arbitrary element of a linked list can be accessed by using the
	double-bracket operator.  The beginning of the list has index 0.
	Thus in the new list x above, the expression x[[0]] returns the
	value of the first element of the list, which is 9.  Note that this
	indexing does not remove elements from the list.

	Since lists are doubly linked in memory, random access to arbitrary
	elements can be slow if the list is large.  However, for each list
	a pointer is kept to the latest indexed element, thus relatively
	sequential accesses to the elements in a list will not be slow.

	Lists can be searched for particular values by using the 'search'
	and 'rsearch' functions.  They return the element number of the
	found value (zero based), or null if the value does not exist in
	the list.


Using files

	The calculator provides some functions which allow the program to
	read or write text files.  These functions use stdio internally,
	and the functions appear similar to some of the stdio functions.
	Some differences do occur, as will be explained here.

	Names of files are subject to ~ expansion just like the C or
	Korn shell.  For example, the file name:

		~/.rc.cal
	
	refers to the file '.rc.cal' under your home directory.  The
	file name:

		~chongo/.rc.cal

	refers to the a file 'rc.cal' under the home directory of 'chongo'.

	A file can be opened for either reading, writing, or appending.
	To do this, the 'fopen' function is used, which accepts a filename
	and an open mode, both as strings.  You use 'r' for reading, 'w'
	for writing, and 'a' for appending.  For example, to open the file
	'foo' for reading, the following could be used:

		fd = fopen('foo', 'r');

	If the open is unsuccessful, the numeric value of errno is returned.
	If the open is successful, a value of type 'file' will be returned.
	You can use the 'isfile' function to test the return value to see
	if the open succeeded.  You should assign the return value of fopen
	to a variable for later use.  File values can be copied to more than
	one variable, and using any of the variables with the same file value
	will produce the same results.

	If you overwrite a variable containing a file value or don't save the
	result of an 'fopen', the opened file still remains open.  Such 'lost'
	files can be recovered by using the 'files' function.  This function
	either takes no arguments or else takes one integer argument.  If no
	arguments are given, then 'files' returns the maximum number of opened
	files.  If an argument is given, then the 'files' function uses it as
	an index into an internal table of open files, and returns a value
	referring to one the open files.  If that entry in the table is not
	in use, then the null value is returned instead.  Index 0 always
	refers to standard input, index 1 always refers to standard output,
	and index 2 always refers to standard error.  These three files are
	already open by the calculator and cannot be closed.  As an example
	of using 'files', if you wanted to assign a file value which is
	equivalent to stdout, you could use:

		stdout = files(1);

	The 'fclose' function is used to close a file which had been opened.
	When this is done, the file value associated with the file remains
	a file value, but appears 'closed', and cannot be used in further
	file-related calls (except fclose) without causing errors.  This same
	action occurs to all copies of the file value.  You do not need to
	explicitly close all the copies of a file value.  The 'fclose'
	function returns the numeric value of errno if there had been an
	error using the file, or the null value if there was no error.

	File values can be printed.  When this is done, the filename of the
	opened file is printed inside of quote marks.  If the file value had
	been closed, then the null string is printed.  If a file value is the
	result of a top-level expression, then in addition to the filename,
	the open mode, file position, and possible EOF, error, and closed
	status is also displayed.

	File values can be used inside of 'if' tests.  When this is done,
	an opened file is TRUE, and a closed file is FALSE.  As an example
	of this, the following loop will print the names of all the currently
	opened non-standard files with their indexes, and then close them:

		for (i = 3; i < files(); i++) {
			if (files(i)) {
				print i, files(i);
				fclose(files(i));
			}
		}

	The functions to read from files are 'fgetline' and 'fgetc'.
	The 'fgetline' function accepts a file value, and returns the next
	input line from a file.  The line is returned as a string value, and
	does not contain the end of line character.  Empty lines return the
	null string.  When the end of file is reached, fgetline returns the
	null value.  (Note the distinction between a null string and a null
	value.)  If the line contained a numeric value, then the 'eval'
	function can then be used to convert the string to a numeric value.
	Care should be used when doing this, however, since eval will
	generate an error if the string doesn't represent a valid expression.
	The 'fgetc' function returns the next character from a file as a
	single character string.  It returns the null value when end of file
	is reached.

	The 'printf' and 'fprintf' functions are used to print results to a
	file (which could be stdout or stderr).  The 'fprintf' function
	accepts a file variable, whereas the 'printf' function assumes the
	use of 'files(1)' (stdout).  They both require a format string, which
	is used in almost the same way as in normal C.  The differences come
	in the interpretation of values to be printed for various formats.
	Unlike in C, where an unmatched format type and value will cause
	problems, in the calculator nothing bad will happen.  This is because
	the calculator knows the types of all values, and will handle them
	all reasonably.  What this means is that you can (for example), always
	use %s or %d in your format strings, even if you are printing a non-
	string or non-numeric value.  For example, the following is valid:

		printf("Two values are %d and %s\n", "fred", 4567);

	and will print "Two values are fred and 4567".

	Using particular format characters, however, is still useful if
	you wish to use width or precision arguments in the format, or if
	you wish to print numbers in a particular format.  The following
	is a list of the possible numeric formats:

		%d		print in currently defined numeric format
		%f		print as floating point
		%e		print as exponential
		%r		print as decimal fractions
		%x		print as hex fractions
		%o		print as octal fractions
		%b		print as binary fractions

	Note then, that using %d in the format makes the output configurable
	by using the 'config' function to change the output mode, whereas
	the other formats override the mode and force the output to be in
	the specified format.

	Using the precision argument will override the 'config' function
	to set the number of decimal places printed.  For example:

		printf("The number is %.100f\n", 1/3);

	will print 100 decimal places no matter what the display configuration
	value is set to.

	The %s and %c formats are identical, and will print out the string
	representation of the value.  In these cases, the precision argument
	will truncate the output the same way as in standard C.

	If a matrix or list is printed, then the output mode and precision
	affects the printing of each individual element.  However, field
	widths are ignored since these values print using multiple lines.
	Field widths are also ignored if an object value prints on multiple
	lines.

	The final file-related functions are 'fflush', 'ferror', and 'feof'.
	The 'fflush' function forces buffered output to a file.  The 'ferror'
	function returns nonzero if an error had occurred to a file.  The
	'feof' function returns nonzero if end of file has been reached
	while reading a file.

	The 'strprintf' function formats output similarly to 'printf',
	but the output is returned as a string value instead of being
	printed.


Builtin functions

	There is a large number of built-in functions.  Many of the
	functions work on several types of arguments, whereas some only
	work for the correct types (e.g., numbers or strings).  In the
	following description, this is indicated by whether or not the
	description refers to values or numbers.  This display is generated
	by the 'show builtins' command.

		Name	Args	Description

		abs       1-2    absolute value within accuracy b
		acos      1-2    arccosine of a within accuracy b
		acosh     1-2    hyperbolic arccosine of a within accuracy b
		append    2      append value to end of list
		appr      1-2    approximate a with simpler fraction to within b
		arg       1-2    argument (the angle) of complex number
		asin      1-2    arcsine of a within accuracy b
		asinh     1-2    hyperbolic arcsine of a within accuracy b
		atan      1-2    arctangent of a within accuracy b
		atan2     2-3    angle to point (b,a) within accuracy c
		atanh     1-2    hyperbolic arctangent of a within accuracy b
		avg       1+     arithmetic mean of values
		bround    1-2    round value a to b number of binary places
		btrunc    1-2    truncate a to b number of binary places
		ceil      1      smallest integer greater than or equal to number
		cfappr    1-2    approximate a within accuracy b using
				continued fractions
		cfsim     1      simplify number using continued fractions
		char      1      character corresponding to integer value
		cmp       2      compare values returning -1, 0, or 1
		comb      2      combinatorial number a!/b!(a-b)!
		config    1-2    set or read configuration value
		conj      1      complex conjugate of value
		cos       1-2    cosine of value a within accuracy b
		cosh      1-2    hyperbolic cosine of a within accuracy b
		cp        2      cross product of two vectors
		delete    2      delete element from list a at position b
		den       1      denominator of fraction
		det       1      determinant of matrix
		digit     2      digit at specified decimal place of number
		digits    1      number of digits in number
		dp        2      dot product of two vectors
		epsilon   0-1    set or read allowed error for real calculations
		eval      1      evaluate expression from string to value
		exp       1-2    exponential of value a within accuracy b
		fcnt      2      count of times one number divides another
		fib       1      Fibonacci number F(n)
		frem      2      number with all occurrence of factor removed
		fact      1      factorial
		fclose    1      close file
		feof      1      whether EOF reached for file
		ferror    1      whether error occurred for file
		fflush    1      flush output to file
		fgetc     1      read next char from file
		fgetline  1      read next line from file
		files     0-1    return opened file or max number of opened files
		floor     1      greatest integer less than or equal to number
		fopen     2      open file name a in mode b
		fprintf   2+     print formatted output to opened file
		frac      1      fractional part of value
		gcd       1+     greatest common divisor
		gcdrem    2      a divided repeatedly by gcd with b
		highbit   1      high bit number in base 2 representation
		hmean     1+     harmonic mean of values
		hypot     2-3    hypotenuse of right triangle within accuracy c
		ilog      2      integral log of one number with another
		ilog10    1      integral log of a number base 10
		ilog2     1      integral log of a number base 2
		im        1      imaginary part of complex number
		insert    3      insert value c into list a at position b
		int       1      integer part of value
		inverse   1      multiplicative inverse of value
		iroot     2      integer b'th root of a
		iseven    1      whether a value is an even integer
		isfile    1      whether a value is a file
		isint     1      whether a value is an integer
		islist    1      whether a value is a list
		ismat     1      whether a value is a matrix
		ismult    2      whether a is a multiple of b
		isnull    1      whether a value is the null value
		isnum     1      whether a value is a number
		isobj     1      whether a value is an object
		isodd     1      whether a value is an odd integer
		isqrt     1      integer part of square root
		isreal    1      whether a value is a real number
		isset     2      whether bit b of abs(a) (in base 2) is set
		isstr     1      whether a value is a string
		isrel     2      whether two numbers are relatively prime
		issimple  1      whether value is a simple type
		issq      1      whether or not number is a square
		istype    2      whether the type of a is same as the type of b
		jacobi    2      -1 => a is not quadratic residue mod b
				 1 => b is composite, or a is quad residue of b
		lcm       1+     least common multiple
		lcmfact   1      lcm of all integers up till number
		lfactor   2      lowest prime factor of a in first b primes
		list      0+     create list of specified values
		ln        1-2    natural logarithm of value a within accuracy b
		lowbit    1      low bit number in base 2 representation
		ltol      1-2    leg-to-leg of unit right triangle
			         (sqrt(1 - a^2))
		matdim    1      number of dimensions of matrix
		matfill   2-3    fill matrix with value b (value c on diagonal)
		matmax    2      maximum index of matrix a dim b
		matmin    2      minimum index of matrix a dim b
		mattrans  1      transpose of matrix
		max       1+     maximum value
		meq       3      whether a and b are equal modulo c
		min       1+     minimum value
		minv      2      inverse of a modulo b
		mmin      2      a mod b value with smallest abs value
		mne       3      whether a and b are not equal modulo c
		near      2-3    sign of (abs(a-b) - c)
		norm      1      norm of a value (square of absolute value)
		null      0      null value
		num       1      numerator of fraction
		ord       1      integer corresponding to character value
		param     1      value of parameter n (or parameter count if
			         n is zero)
		perm      2      permutation number a!/(a-b)!
		pfact     1      product of primes up till number
		pi        0-1    value of pi accurate to within epsilon
		places    1      places after decimal point (-1 if infinite)
		pmod      3      mod of a power (a ^ b (mod c))
		polar     2-3    complex value of polar coordinate
			         (a * exp(b*1i))
		poly      2+     (a1,a2,...,an,x) = a1*x^n+a2*x^(n-1)+...+an
		pop       1      pop value from front of list
		power     2-3    value a raised to the power b within accuracy c
		ptest     2      probabilistic primality test
		printf    1+     print formatted output to stdout
		prompt    1      prompt for input line using value a
		push      2      push value onto front of list
		quomod    4      set c and d to quotient and remainder of a divided by b
		rcin      2      convert normal number a to REDC number mod b
		rcmul     3      multiply REDC numbers a and b mod c
		rcout     2      convert REDC number a mod b to normal number
		rcpow     3      raise REDC number a to power b mod c
		rcsq      2      square REDC number a mod b
		re        1      real part of complex number
		remove    1      remove value from end of list
		root      2-3    value a taken to the b'th root within accuracy c
		round     1-2    round value a to b number of decimal places
		rsearch   2-3    reverse search matrix or list for value b
			         starting at index c
		runtime   0      user mode cpu time in seconds
		scale     2      scale value up or down by a power of two
		search    2-3    search matrix or list for value b starting at
			         index c
		sgn       1      sign of value (-1, 0, 1)
		sin       1-2    sine of value a within accuracy b
		sinh      1-2    hyperbolic sine of a within accuracy b
		size      1      total number of elements in value
		sqrt      1-2    square root of value a within accuracy b
		ssq       1+     sum of squares of values
		str       1      simple value converted to string
		strcat    1+     concatenate strings together
		strlen    1      length of string
		strprintf 1+     return formatted output as a string
		substr    3      substring of a from position b for c chars
		swap      2      swap values of variables a and b
			         (can be dangerous)
		tan       1-2    tangent of a within accuracy b
		tanh      1-2    hyperbolic tangent of a within accuracy b
		trunc     1-2    truncate a to b number of decimal places
		xor       1+     logical xor


	The config function sets or reads the value of a configuration
	parameter.  The first argument is a string which names the parameter
	to be set or read.  If only one argument is given, then the current
	value of the named parameter is returned.  If two arguments are given,
	then the named parameter is set to the value of the second argument,
	and the old value of the parameter is returned.  Therefore you can
	change a parameter and restore its old value later.  The possible
	parameters are explained in the next section.

	The scale function multiplies or divides a number by a power of 2.
	This is used for fractional calculations, unlike the << and >>
	operators, which are only defined for integers.  For example,
	scale(6, -3) is 3/4.

	The quomod function is used to obtain both the quotient and remainder
	of a division in one operation.  The first two arguments a and b are
	the numbers to be divided.  The last two arguments c and d are two
	variables which will be assigned the quotient and remainder.  For
	nonnegative arguments, the results are equivalent to computing a//b
	and a%b.  If a is negative and the remainder is nonzero, then the
	quotient will be one less than a//b.  This makes the following three
	properties always hold:  The quotient c is always an integer.  The
	remainder d is always 0 <= d < b.  The equation a = b * c + d always
	holds.  This function returns 0 if there is no remainder, and 1 if
	there is a remainder.  For examples, quomod(10, 3, x, y) sets x to 3,
	y to 1, and returns the value 1, and quomod(-4, 3.14159, x, y) sets x
	to -2, y to 2.28318, and returns the value 1.

	The eval function accepts a string argument and evaluates the
	expression represented by the string and returns its value.
	The expression can include function calls and variable references.
	For example, eval("fact(3) + 7") returns 13.  When combined with
	the prompt function, this allows the calculator to read values from
	the user.  For example, x=eval(prompt("Number: ")) sets x to the
	value input by the user.

	The digit and isset functions return individual digits of a number,
	either in base 10 or in base 2, where the lowest digit of a number
	is at digit position 0.  For example, digit(5678, 3) is 5, and
	isset(0b1000100, 2) is 1.  Negative digit positions indicate places
	to the right of the decimal or binary point, so that for example,
	digit(3.456, -1) is 4.

	The ptest function is a primality testing function.  The first
	argument is the suspected prime to be tested.  The second argument
	is an iteration count.  The function returns 0 if the number is
	definitely not prime, and 1 is the number is probably prime.  The
	chance of a number which is probably prime being actually composite
	is less than 1/4 raised to the power of the iteration count.  For
	example, for a random number p, ptest(p, 10) incorrectly returns 1
	less than once in every million numbers, and you will probably never
	find a number where ptest(p, 20) gives the wrong answer.

	The functions rcin, rcmul, rcout, rcpow, and rcsq are used to
	perform modular arithmetic calculations for large odd numbers
	faster than the usual methods.  To do this, you first use the
	rcin function to convert all input values into numbers which are
	in a format called REDC format.  Then you use rcmul, rcsq, and
	rcpow to multiply such numbers together to produce results also
	in REDC format.  Finally, you use rcout to convert a number in
	REDC format back to a normal number.  The addition, subtraction,
	negation, and equality comparison between REDC numbers are done
	using the normal modular methods.  For example, to calculate the
	value 13 * 17 + 1 (mod 11), you could use:

		p = 11;
		t1 = rcin(13, p);
		t2 = rcin(17, p);
		t3 = rcin(1, p);
		t4 = rcmul(t1, t2, p);
		t5 = (t4 + t3) % p;
		answer = rcout(t5, p);

	The swap function exchanges the values of two variables without
	performing copies.  For example, after:

		x = 17;
		y = 19;
		swap(x, y);

	then x is 19 and y is 17.  This function should not be used to
	swap a value which is contained within another one.  If this is
	done, then some memory will be lost.  For example, the following
	should not be done:

		mat x[5];
		swap(x, x[0]);


Configuration parameters

	Configuration parameters affect how the calculator performs certain
	operations, and affects all future calculations.  These parameters
	affect the accuracy of calculations, the displayed format of results,
	and which algorithms are used for calculations.  The parameters are
	read or set using the "config" built-in function.  The following
	parameters can be specified:

		"trace"		turns tracing on or off (for debugging).
		"display"	sets number of digits in prints.
		"epsilon"	sets error value for transcendentals.
		"maxprint"	sets maximum number of elements printed.
		"mode"		sets printout mode.
		"mul2"		sets size for alternative multiply.
		"sq2"		sets size for alternative squaring.
		"pow2"		sets size for alternate powering.
		"redc2"		sets size for alternate REDC.

	The use of the trace flag is for debugging, and its meaning may
	change in the future.  A value of 1 causes the calculator to print
	its internal opcodes as it executes functions.  A value of zero
	disables tracing again.

	Display specifies how many digits after the decimal point should
	be printed when printing real or exponential numbers.  The initial
	display value is 20.  This parameter does not affect the accuracy
	of a calculation, since it only has meaning when printing results.

	Epsilon specifies the required precision of calculations by
	setting the maximum allowed error for transcendental functions.
	The error is an absolute error value for many functions, but
	for some functions it is a relative error.  The initial value
	is 1e-20.  Functions which require an epsilon value accept an
	optional argument which overrides this default epsilon value for
	that single call.  The built-in function "epsilon" also can be
	used to read or set this value, and is provided for ease of use.

	Mode specifies how numbers should be printed.  Mode is a string
	value indicating the printout method.  The initial mode is "real".
	Possible modes are:

		"frac"		decimal fractions
		"int"		decimal integer
		"real"		decimal floating point
		"exp"		decimal exponential
		"hex"		hex fractions
		"oct"		octal fractions
		"bin"		binary fractions

	Maxprint specifies the maximum number of elements to be displayed
	when a matrix or list is printed.  The initial value is 16 elements.

	Mul2 and sq2 specify the sizes of numbers at which calc switches
	from its first to its second algorithm for multiplying and squaring.
	The first algorithm is the usual method of cross multiplying, which
	runs in a time of O(N^2).  The second method is a recursive and
	complicated method which runs in a time of O(N^1.585).  The argument
	for these parameters is the number of binary words at which the
	second algorithm begins to be used.  The minimum value is 2, and
	the maximum value is very large.  If 2 is used, then the recursive
	algorithm is used all the way down to single digits, which becomes
	slow since the recursion overhead is high.  If a number such as
	1000000 is used, then the recursive algorithm is never used, causing
	calculations for large numbers to slow down.  For a typical example
	on a 386, the two algorithms are about equal in speed for a value
	of 20, which is about 100 decimal digits.  A value of zero resets
	the parameter back to its default value.  Usually there is no need
	to change these parameters.

	Pow2 specifies the sizes of numbers at which calc switches from
	its first to its second algorithm for calculating powers modulo
	another number.  The first algorithm for calculating modular powers
	is by repeated squaring and multiplying and dividing by the modulus.
	The second method uses the REDC algorithm given by Peter Montgomery
	which avoids divisions.  The argument for pow2 is the size of the
	modulus at which the second algorithm begins to be used.

	Redc2 specifies the sizes of numbers at which calc switches from
	its first to its second algorithm when using the REDC algorithm.
	The first algorithm performs a multiply and a modular reduction
	together in one loop which runs in O(N^2).  The second algorithm
	does the REDC calculation using three multiplies, and runs in
	O(N^1.585).  The argument for redc2 is the size of the modulus at
	which the second algorithm begins to be used.

	Examples of setting some parameters are:

		config("mode", "exp");		exponential output
		config("display", 50);		50 digits of output
		epsilon(epsilon() / 8);		3 bits more accuracy


Interrupts

	While a calculation is in progress, you can generate the SIGINT
	signal, and the calculator will catch it.  At appropriate points
	within a calculation, the calculator will check that the signal
	has been given, and will abort the calculation cleanly.  If the
	calculator is in the middle of a large calculation, it might be
	a while before the interrupt has an effect.

	You can generate the SIGINT signal multiple times if necessary,
	and each time the calculator will abort the calculation at a more
	risky place within the calculation.  Each new interrupt prints a
	message of the form:

		[Abort level n]

	where n ranges from 1 to 3.  For n equal to 1, the calculator will
	abort calculations at the next statement boundary.  For n equal to 2,
	the calculator will abort calculations at the next opcode boundary.
	For n equal to 3, the calculator will abort calculations at the next
	lowest level arithmetic operation boundary.

	If a final interrupt is given when n is 3, the calculator will
	immediately abort the current calculation and longjmp back to the
	top level command level.  Doing this may result in corrupted data
	structures and unpredictable future behavior, and so should only
	be done as a last resort.  You are advised to quit the calculator
	after this has been done.


Command history

	There is a crude command history feature in the calculator.
	If a terminal line begins with an exclamation mark or back quote
	character (! or `), then the terminal line is handled specially.

	The command just typed can be re-executed by typing the
	line '``' (two back quotes).

	Other previous commands can be executed again by typing '`nn'
	(backquote <number>), where nn is the command number to be 
	ex-executed.  This number is displayed in the prompt for each 
	input line, so it is easy to re-execute commands that are still 
	visible on the screen.  Negative numbers can be used to re-execute 
	the n'th command back.

	The list of 20 previous commands can be displayed by typing '`h'
	(backquote h).  By typing '`hnn' (backquote h <number>), one
	can ex-execute the last 'nn' commands.

	Up to 255 commands are saved in the history stack.

	A UNIX command can be executed by typing '!cmd', where cmd
	is the command to execute.  If cmd is not given, then a shell
	command level is started.


Calc command line

	Calc has the following command line:

		calc [-h] [-q] [calc_command ...]

		-h	print a help message  (equivalent to the
			help command)

		-q	By default, calc executes each file specified
			in the :-separated list found in the environment
			variable $CALCRC.  If $CALCRC does not exist,
			an internal default is used.

	If some calc_commands arguments are given on the command line,
	calc executes these commands and then exists.  If no command
	line arguments are given, calc prompts and reads commands
	from standard input.


Credits

	Written by David I. Bell.

	Thanks for suggestions and encouragement from Peter Miller,
	Neil Justusson, and Landon Noll.

	Portions of this program are derived from an earlier set of
	public domain arbitrarily precision routines which was posted
	to the net around 1984.  By now, there is almost no recognizable 
	code left from that original source.

	Most of this source and binary is:

		Copyright (c) 1992 David I. Bell

	A few files are a joint copyright between David I. Bell and Landon Noll.

	Permission is granted to use, distribute, or modify this source,
	provided that this copyright notice remains intact.

	Send calc comments, suggestions, bug fixes, enhancements and
	interesting calc scripts that you would like you see included in
	future distributions to:

		dbell@pdact.pd.necisa.oz.au  and  chongo@toad.com

	Enjoy!
